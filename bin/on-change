#!/usr/bin/env python3
from __future__ import print_function

import signal
import argparse
import fcntl
import os
import sys
import errno
from time import sleep, time
from subprocess import Popen, PIPE, TimeoutExpired
from functools import partial

current_process = None


def oneshot(args, events, action):
    global current_process

    current_process = Popen(args)
    current_process.wait()
    for r in events:
        current_process = Popen(args)
        current_process.wait()
        action and action()


def longpoll(args, events, action):
    global current_process
    start = time()
    current_process = Popen(args)
    for r in events:
        if start + 1 < r:
            current_process.terminate()
            current_process.wait()
            action and action()
            start = time()
            current_process = Popen(args)


def get_events(watch_list, exclude, timeout=0.3):
    cmd = ['inotifywait', '-m', '-r', '-e', 'create', '-e', 'modify']
    if exclude:
        cmd += ['--exclude', exclude]
    wp = Popen(cmd + watch_list, stdout=PIPE)
    fcntl.fcntl(wp.stdout, fcntl.F_SETFL, os.O_NONBLOCK)

    def shutdown(signal, frame):
        if current_process:
            current_process.terminate()
            try:
                current_process.wait(2)
            except TimeoutExpired:
                current_process.kill()
                current_process.wait()
        sys.exit(0)

    signal.signal(signal.SIGINT, shutdown)
    signal.signal(signal.SIGTERM, shutdown)

    def read():
        try:
            return wp.stdout.read()
        except IOError as e:
            if e.errno == errno.EAGAIN:
                return
            else:
                raise

    start = None
    while True:
        data = read()

        if data:
            start = time()
            continue

        if start and time() - start > timeout:
            start = None
            yield time()
            read()

        sleep(0.3)


def action_touch(filename):
    from pathlib import Path
    Path(filename).touch()


def action_fifo(filename):
    if not os.path.exists(filename):
        os.mkfifo(filename)

    with open(filename, 'wb') as f:
        f.write(b'1')


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-w', dest='watch', action='append')
    parser.add_argument('-e', dest='exclude')
    parser.add_argument('-d', dest='daemon', action='store_true')
    parser.add_argument('--touch', dest='touch')
    parser.add_argument('--fifo', dest='fifo')

    args, rest = parser.parse_known_args()

    if not rest:
        print('You should provide a command to execute on change', file=sys.stderr)
        sys.exit(1)

    if rest[0] == '--':
        rest = rest[1:]

    action = None
    if args.touch:
        action = partial(action_touch, args.touch)
    if args.fifo:
        action = partial(action_fifo, args.fifo)

    watch_list = args.watch or ['.']
    try:
        if args.daemon:
            longpoll(rest, get_events(watch_list, args.exclude), action)
        else:
            oneshot(rest, get_events(watch_list, args.exclude), action)
    except KeyboardInterrupt:
        pass
